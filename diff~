38c38
< verbose = 4
---
> verbose = 3
61,62c61,62
<          T(j,1) = lettore1
<          S(j,1) = lettore2
---
>          T(i,1) = lettore1
>          S(i,1) = lettore2
67,68c67,68
< T(1,1)=0.d0
< S(1,1)=0.d0
---
> T(n,1)=-100.d0
> S(n,1)=-100.d0
70,76c70,72
< !ATTENZIONE!
< !Il contenuto della sopradiagonale di T (e similmente di S)
< !lo leggo in T(2:n,1), cioe` partendo dal secondo elemento di T(:,1)
< 
< do i=1,n
<    write(*,*)"S(",i,",0)=",S(i,0)
< end do
---
> !do i=1,n
> !   write(*,*)"S(i,0)=",S(i,0)
> !end do
78,80c74,76
< do i=1,n
<    write(*,*)"S(",i,",1)=",S(i,1)
< end do
---
> !do i=1,n
> !   write(*,*)"S(i,1)=",S(i,1)
> !end do
135c131
< Open(unit=3,file="risultato_i_inerzia.txt")
---
> Open(unit=3,file="risultato_i.txt")
172c168
< Open(unit=4,file="risultato_ii_inerzia.txt")
---
> Open(unit=4,file="risultato_ii.txt")
213c209
< Open(unit=5,file="risultato_iii_inerzia.txt")
---
> Open(unit=5,file="risultato_iii.txt")
409c405
<       call numAutovaloriPrimaDiX(a,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
---
>       !call numAutovaloriPrimaDiX(a,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
419c415
<       call numAutovaloriPrimaDiX(b,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
---
>       !call numAutovaloriPrimaDiX(b,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
478c474
<             call numAutovaloriPrimaDiX(x,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
---
>             !call numAutovaloriPrimaDiX(x,dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
705c701
<    if ( l >= 15 ) then
---
>    if ( l >= 150 ) then
812c808
<    call numAutovaloriPrimaDiX(xl(0),dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
---
>    !call numAutovaloriPrimaDiX(xl(0),dim,T(Tinizio:Tfine,:),S(Sinizio:Sfine,:),numAut)
885,886c881
< real(dp), dimension(:), allocatable :: xi
< real(dp), dimension(:), allocatable ::  eta, zeta
---
> real(dp), dimension(-2:0) :: xi, eta, zeta
906,907c901,903
< allocate( xi(1:dim), eta(0:dim), zeta(0:dim) )
< 
---
> !ATTENZIONE: tutte le formule che coinvolgono T o S DEVONO partire
> !da Tinizio e da Sinizio. Si noti che T(:,0) ha n elementi,
> !mentre T(:,1) ne ha n-1 (ugualmente S)
918,919c914,920
< if ( verboseCalcoli >= 4 ) then
<    write(*,*)"x=",x
---
> kappa = 0
> 
> xi(-2) = 0.d0
> 
> xi(-1) = T(Tinizio,0) - x * S(Sinizio,0)
> if ( abs(xi(-1)) <= machinePrecision ) then
>    xi(-1) = T(Tinizio,0) * machinePrecision**2
922c923
< kappa = 0
---
> xi(0)=xi(-1)
924d924
< do i=0,dim
926,929c926,953
<    if ( i==0 ) then
<       eta(0)=0.d0
<       zeta(0)=0.d0
<    end if
---
> if ( verboseCalcoli >= 5 ) then
>    write(*,*) "-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-"
>    write(*,*) "x in ingresso=",x
> end if
> 
> if ( xi(0) < 0.d0 ) then
>    kappa = kappa+1
> end if
> 
> 
> if ( verboseCalcoli >= 5 ) then
>    write(*,*)"xi(0)=",xi(0),"kappa=",kappa
> end if
> 
> eta(-2) = 0.d0
> eta(-1) = S(Sinizio,0)/xi(0)
> eta(0) = eta(-1)
> 
> zeta(-2) = 0.d0
> zeta(-1) = zeta(-2)
> zeta(0) = zeta(-1)
> 
> 
> 
> do i=1,dim-1
> 
>    !write(*,*)"T(Tinizio+i,0)=T(",Tinizio+i,",0)=",T(Tinizio+i,0)
>    !write(*,*)"T(Tinizio+i-1,1)=T(",Tinizio+i-1,",1)=",T(Tinizio+i-1,1)
931,936c955,960
<    if ( i==1 ) then
<       xi(1)=T(Tinizio,0)-x*S(Sinizio,0)
<       
<       if ( abs(xi(1)) <= machinePrecision ) then
<          xi(1) = T(Tinizio,0)*machinePrecision**2
<       end if
---
>    !mi occupo di xi
>    
>    xi(0) = T(Tinizio+i,0) - x*S(Sinizio+i,0) - &
>    (( T(Tinizio+i-1,1)-x*S(Sinizio+i-1,1) )**2)/&
>    xi(-1)
> 
938,939c962,965
<       eta(1)=S(Sinizio,0)/xi(1)
<       zeta(1)=0.d0
---
>    if ( abs(xi(0)) <= machinePrecision ) then
>       xi(0) = ( (abs(T(Tinizio+i-1,1))+ & 
>       abs(x*S(Sinizio+i-1,1)) )**2 * machinePrecision**2 )/&
>       xi(-1)
940a967
> 
941a969,971
>    if ( xi(0) < 0.d0 ) then
>       kappa = kappa + 1
>    end if
943,945d972
<    if ( i>=2 ) then
<       !Se mi trovo qui allora i>=2
<       xi(i) = T(Tinizio-1+i,0) - x*S(Sinizio-1+i,0) - (T(Tinizio-1+i,1) - x*S(Sinizio-1+i,1) )**2/xi(i-1)
947,949c974,979
<       if ( abs(xi(i)) <= machinePrecision ) then
<          xi(i) = ( (abs(T(Tinizio-1+i,1))+abs(x*S(Sinizio-1+i,1)))**2 * machinePrecision**2  )/xi(i-1)
<       end if
---
>    if ( verboseCalcoli >= 5 ) then
>       write(*,*)"xi(0)=",xi(0),"kappa=",kappa
>    end if
> 
>    !mi occupo di eta:
>    !divido in due tappe il calcolo.
951,954c981,987
<       eta(i) = 2.d0 * (T(Tinizio-1+i,1) - x*S(Sinizio-1+i,1)) * S(Sinizio-1+i,1) + &
<            (T(Tinizio-1+i,1) - x*S(Sinizio-1+i,1))**2 * eta(i-2)
<       eta(i) = -eta(i)/xi(i-1)
<       eta(i) = ( eta(i) + (T(Tinizio-1+i,0) - x*S(Sinizio-1+i,0))*eta(i-1) + S(Sinizio-1+i,0) )/xi(i)
---
>    eta(0) =2.d0*(T(Tinizio+i,0)-x*S(Sinizio+i,0))*&
>    S(Sinizio+i-1,1) + (T(Tinizio+i-1,1)- &
>    x*S(Sinizio+i-1,1))**2*eta(-2)
>       
>    if ( abs(eta(0))<= machinePrecision ) then
>       write(*,*)"primo pezzo di eta e` zero!"
>    end if
956,959c989,990
<       zeta(i) = 2.d0*S(Sinizio-1+i,1)**2 * 4.d0*(T(Tinizio-1+i,1) - x*S(Sinizio-1+i,1))*S(Sinizio-1+i,1)*eta(i-2) - &
<            (T(Tinizio-1+i,1) - x*S(Sinizio-1+i,1))**2 * zeta(i-2)
<       zeta(i) = -zeta(i)/xi(i-1)
<       zeta(i) = ( zeta(i) + (T(Tinizio-1+i,0) - x*S(Sinizio-1+i,0))*zeta(i-1) + 2.d0*S(Sinizio-1+i,0)*eta(i-1) )/xi(i)
---
>    eta(0) = ( (T(Tinizio+i,0)-x*S(Sinizio+i,0))* &
>    eta(-1) + S(Sinizio+i,0) - eta(0)/xi(-1) )/xi(0)
960a992,1006
>    if ( abs(eta(0))<= machinePrecision ) then
>       write(*,*)"secondo -ed ultimo- pezzo di eta e` zero!"
>    end if
>    
>    !mi occupo di zeta: 
>    !divido in due tappe il calcolo.
>       
>    zeta(0) = 2.d0*S(Sinizio+i-1,1)**2 + &
>    4.d0*( T(Tinizio+i-1,1)-x*S(Sinizio+i-1,1) )*&
>    S(Sinizio+i-1,1)*eta(-2) - &
>    ( T(Tinizio+i-1,1)-x*S(Sinizio+i-1,1) )**2*&
>    zeta(-2)
> 
>    if ( abs(zeta(0))<= machinePrecision ) then
>       write(*,*)"primo pezzo di zeta e` zero!"
963,965c1009,1014
<    !Adesso aggiorno il conteggio degli xi negativi
<    if ( xi(i) < 0.d0 ) then
<       kappa = kappa + 1
---
>    zeta(0) = (( T(Tinizio+i,0) -x*S(Sinizio+i,0))*&
>    zeta(-1) + 2.d0*S(Sinizio+i,0)*eta(-1) - &
>    zeta(0)/xi(-1) )/xi(0)
>    
>    if ( abs(zeta(0))<= machinePrecision ) then
>       write(*,*)"secondo -ed ultimo- pezzo di zeta e` zero!"
968,969c1017,1022
<    if ( verboseCalcoli >= 5 ) then
<       write(*,*)"i=",i,"kappa=",kappa
---
> 
>    if ( verboseCalcoli >= 6 ) then
>       write(*,*)"xi(-2)=",xi(-2),"xi(-1)=",xi(-1),"xi(0)=",xi(0)
>       write(*,*)"eta(-2)=",eta(-2),"eta(-1)=",eta(-1),"eta(0)=",eta(0)
>       write(*,*)"zeta(-2)=",zeta(-2),"zeta(-1)=",zeta(-1), &
>            "zeta(0)=", zeta(0)
970a1024,1028
>       
>    !aggiiorno le variabili
>       
>    xi(-2)=xi(-1)
>    xi(-1)=xi(0)
972c1030,1031
< end do
---
>    eta(-2)=eta(-1)
>    eta(-1)=eta(0)
974,981c1033,1037
< if ( verboseCalcoli >= 6 ) then
<    write(*,*)"ecco il vettore xi:"
<    write(*,*)xi(:)
<    write(*,*)"ecco il vettore eta:"
<    write(*,*)eta(:)
<    write(*,*)"ecco il vettore zeta:"
<    write(*,*)zeta(:)
< end if
---
>    zeta(-2) = zeta(-1)
>    zeta(-1) = zeta(0)
> 
>    
> end do
985,986c1041,1042
< fPrimo = - eta(dim)
< fSecondo = zeta(dim)
---
> fPrimo = - eta(0)
> fSecondo = zeta(0)
1068,1148c1124,1164
< !!!
< !SUBROUTINE PER IL CALCOLO INERZA
< !!!
< 
< subroutine numAutovaloriPrimaDiX(x,n,U,V,numAut)
< 
< implicit none
< 
< integer, parameter :: dp = kind(1.d0)
< 
< integer, intent(IN) :: n
< 
< real(dp), intent(IN) :: x
< 
< real(dp), dimension(n,0:1), intent(IN) :: U
< 
< real(dp), dimension(n,0:1), intent(IN) :: V
< 
< integer, intent(OUT) :: numAut
< 
< !!!
< 
< real(dp), dimension(:,:), allocatable :: T,S
< 
< character :: UPLO
< 
< integer :: i, j, k, LWORK
< 
< integer, dimension(:), allocatable :: IPIV
< 
< integer :: INFO
< 
< real(dp), dimension(:), allocatable :: WORK
< 
< real(dp), dimension(:,:), allocatable :: A, xI
< 
< real(dp) :: machinePrecision
< 
< !!!
< !FINE DICHIARAZIONI
< !!!
< 
< machinePrecision=epsilon(1.d0)
< 
< allocate( T(n,n), S(n,n) )
< 
< 
< do i=1,n
<    do j=1,n
<       if ( i==j ) then
<          T(i,j)=U(i,0)
<          S(i,j)=V(i,0)
<       else if ( abs(i-j)==1 ) then
<          T(i,j)=U(i,1)
<          S(i,j)=V(i,1)
<       else
<          T(i,j)=0.d0
<          S(i,j)=0.d0
<       end if
<    end do
< end do
< 
< allocate( A(n,n), xI(n,n) )
< allocate( IPIV(n) )
< 
< !compongo xI
< do i=1,n
<    do j=1,n
<       if ( i==j ) then
<          xI(i,j)=x
<       else
<          xI(i,j)=0.d0
<       end if
<    end do
< end do
< 
< UPLO = "L"
< 
< 
< !!$!fattorizzazione di Cholesky S=LL^T
< !!$call DPOTRF(UPLO, n, S, n, INFO)
---
> !!$!!!
> !!$!SUBROUTINE PER IL CALCOLO INERZA
> !!$!!!
> !!$
> !!$subroutine numAutovaloriPrimaDiX(x,n,U,V,numAut)
> !!$
> !!$implicit none
> !!$
> !!$integer, parameter :: dp = kind(1.d0)
> !!$
> !!$integer, intent(IN) :: n
> !!$
> !!$real(dp), intent(IN) :: x
> !!$
> !!$real(dp), dimension(n,0:1), intent(IN) :: U
> !!$
> !!$real(dp), dimension(n,0:1), intent(IN) :: V
> !!$
> !!$integer, intent(OUT) :: numAut
> !!$
> !!$!!!
> !!$
> !!$real(dp), dimension(:,:), allocatable :: T,S
> !!$
> !!$character :: UPLO
> !!$
> !!$integer :: i, j, k, LWORK
> !!$
> !!$integer, dimension(:), allocatable :: IPIV
> !!$
> !!$integer :: INFO
> !!$
> !!$real(dp), dimension(:), allocatable :: WORK
> !!$
> !!$real(dp), dimension(:,:), allocatable :: A, xI
> !!$
> !!$real(dp) :: machinePrecision
> !!$
> !!$!!!
> !!$!FINE DICHIARAZIONI
> !!$!!!
1150c1166,1214
< !!$!cancello la parte sopradiagonale
---
> !!$machinePrecision=epsilon(1.d0)
> !!$
> !!$allocate( T(n,n), S(n,n) )
> !!$
> !!$
> !!$do i=1,n
> !!$   do j=1,n
> !!$      if ( i==j ) then
> !!$         T(i,j)=U(i,0)
> !!$         S(i,j)=V(i,0)
> !!$      else if ( abs(i-j)==1 ) then
> !!$         T(i,j)=U(i,1)
> !!$         S(i,j)=V(i,1)
> !!$      else
> !!$         T(i,j)=0.d0
> !!$         S(i,j)=0.d0
> !!$      end if
> !!$   end do
> !!$end do
> !!$
> !!$allocate( A(n,n), xI(n,n) )
> !!$allocate( IPIV(n) )
> !!$
> !!$!compongo xI
> !!$do i=1,n
> !!$   do j=1,n
> !!$      if ( i==j ) then
> !!$         xI(i,j)=x
> !!$      else
> !!$         xI(i,j)=0.d0
> !!$      end if
> !!$   end do
> !!$end do
> !!$
> !!$UPLO = "L"
> !!$
> !!$
> !!$A = T - matmul(xI,S)
> !!$
> !!$do i=1,n
> !!$   do j=1,n
> !!$      if ( abs(A(i,j))<=machinePrecision ) then
> !!$         A(i,j)=0.d0
> !!$      end if
> !!$   end do
> !!$end do
> !!$
> !!$!stampo la matrice A
> !!$!write(*,*)"matrice A"
1152,1156c1216
< !!$!   do j=1,n
< !!$!      if ( i<j ) then
< !!$!         S(i,j) = 0.d0
< !!$!      end if
< !!$!   end do
---
> !!$!   write(*,*)A(i,:)
1159,1160c1219,1225
< !!$!inverto L. Il risultato e` salvato in S
< !!$call DTRTRI(UPLO, "N", n, S, n, INFO)
---
> !!$!cerco il miglior valor per LWORK:
> !!$allocate( WORK(n) )
> !!$call DSYTRF(UPLO, n, A, n, IPIV, WORK, -1, INFO)
> !!$LWORK=WORK(1)
> !!$deallocate( WORK )
> !!$!write(*,*)"LWORK=",LWORK
> !!$allocate( WORK(LWORK) )
1162,1231c1227,1269
< !!$!Compongo la matrice A
< !!$A = matmul(matmul(S,T),transpose(S)) - xI
< 
< A = T - matmul(xI,S)
< 
< do i=1,n
<    do j=1,n
<       if ( abs(A(i,j))<=machinePrecision ) then
<          A(i,j)=0.d0
<       end if
<    end do
< end do
< 
< !stampo la matrice A
< !write(*,*)"matrice A"
< !do i=1,n
< !   write(*,*)A(i,:)
< !end do
< 
< !cerco il miglior valor per LWORK:
< allocate( WORK(n) )
< call DSYTRF(UPLO, n, A, n, IPIV, WORK, -1, INFO)
< LWORK=WORK(1)
< deallocate( WORK )
< !write(*,*)"LWORK=",LWORK
< allocate( WORK(LWORK) )
< 
< !calcolo la fattorizzazione A=LDL^T
< call DSYTRF(UPLO, n, A, n, IPIV, WORK, LWORK, INFO)
< 
< !write(*,*)"INFO=", INFO
< !write(*,*)"IPIV=",IPIV(:)
< 
< !write(*,*)"matrice A dopo DSYTRF"
< !do i=1,n
< !   write(*,*)A(i,:)
< !end do
< 
< numAut=0
< k=1
< do while( k <= n )
<    !write(*,*)"k=",k
<    if ( IPIV(k) > 0 ) then
<       !A(k,k) e` l'inizio di un blocco 1x1
<       !write(*,*)"A(k,k)=",A(k,k)
<       if ( A(k,k) < 0.d0 ) then
<          numAut = numAut + 1
<          !write(*,*)"numAut=",numAut
<       end if
<       k = k+1
<    else
<       !A(k,k) e` l'inizio del blocco 2x2 simmetrico:
<       !|A(k,k)   A(k+1,k)  |
<       !|A(k+1,k) A(k+1,k+1)|
<       !calcolo quindi la fattorizzazione A(k:k+1,k:k+1)=LDL^T 
<       call DSYTRF(UPLO, 2, A(k:k+1,k:k+1), 2, IPIV, WORK, -1, INFO)
<       LWORK=WORK(1)
<       call DSYTRF(UPLO, 2, A(k:k+1,k:k+1), 2, IPIV, WORK, LWORK, INFO)
<       !controllo dunque il segno di A(k,k) e di A(k+1,k+1),
<       !che compongono l'attuale D
<       do j=0,1
<          if ( A(k+j,k+j) < 0.d0 ) then
<             numAut = numAut + 1
<          end if
<       end do
<       k = k+2
<    end if
< end do
< 
< end subroutine numAutovaloriPrimaDiX
---
> !!$!calcolo la fattorizzazione A=LDL^T
> !!$call DSYTRF(UPLO, n, A, n, IPIV, WORK, LWORK, INFO)
> !!$
> !!$!write(*,*)"INFO=", INFO
> !!$!write(*,*)"IPIV=",IPIV(:)
> !!$
> !!$!write(*,*)"matrice A dopo DSYTRF"
> !!$!do i=1,n
> !!$!   write(*,*)A(i,:)
> !!$!end do
> !!$
> !!$numAut=0
> !!$k=1
> !!$do while( k <= n )
> !!$   !write(*,*)"k=",k
> !!$   if ( IPIV(k) > 0 ) then
> !!$      !A(k,k) e` l'inizio di un blocco 1x1
> !!$      !write(*,*)"A(k,k)=",A(k,k)
> !!$      if ( A(k,k) < 0.d0 ) then
> !!$         numAut = numAut + 1
> !!$         !write(*,*)"numAut=",numAut
> !!$      end if
> !!$      k = k+1
> !!$   else
> !!$      !A(k,k) e` l'inizio del blocco 2x2 simmetrico:
> !!$      !|A(k,k)   A(k+1,k)  |
> !!$      !|A(k+1,k) A(k+1,k+1)|
> !!$      !calcolo quindi la fattorizzazione A(k:k+1,k:k+1)=LDL^T 
> !!$      call DSYTRF(UPLO, 2, A(k:k+1,k:k+1), 2, IPIV, WORK, -1, INFO)
> !!$      LWORK=WORK(1)
> !!$      call DSYTRF(UPLO, 2, A(k:k+1,k:k+1), 2, IPIV, WORK, LWORK, INFO)
> !!$      !controllo dunque il segno di A(k,k) e di A(k+1,k+1),
> !!$      !che compongono l'attuale D
> !!$      do j=0,1
> !!$         if ( A(k+j,k+j) < 0.d0 ) then
> !!$            numAut = numAut + 1
> !!$         end if
> !!$      end do
> !!$      k = k+2
> !!$   end if
> !!$end do
> !!$
> !!$end subroutine numAutovaloriPrimaDiX
